# OIDC Tests

## Description

This directory contains a test fixture and IdP mock for testing authentication with OIDC.

## Table of content

1. [Suite definition](#suite)
2. [Identity Provider Server Mock](#idp-server-mock)
3. [Identity Provider Mock](#idp-mock)
4. [Tests Fixture](#tests-fixture)
5. [Notes](#notes)

## Suite

The **OIDC** suite is defined in [oidc.yml](../../../buildscripts/resmokeconfig/suites/oidc.yml) file.

The [Identity Provider Server Mock](#idp-server-mock) starts an **HTTPS** server with [self-signed certificate](./ca_oidc_idp.pem). The `mongo shell` and `mongod` must trust this certificate, and currently, it is required to install the [certificate](./ca_oidc_idp.crt) system-wide.

To prevent tests failures when the certificate is not installed, all tests in the suite are ignored by default unless they are tagged with `oidc_idp_mock_cert_not_required`:

``` js
// @tags: [oidc_idp_mock_cert_not_required]
```

Running all tests in this suite is possible by using the `tagFile` option with `resmoke`:

``` sh
./buildscripts/resmoke.py --suite=oidc --tagFile etc/oidc_idp_mock_cert_installed.yml
```

The provided [tag file](../../../etc/oidc_idp_mock_cert_installed.yml) adds the `oidc_idp_mock_cert_installed` tag to all tests within this suite, thus enabling their execution.

Installing the certificate depends on theoperating system. For example on *Ubuntu 24.04** it can be done with the following commands:

``` sh
sudo cp jstests/oidc/lib/ca_oidc_idp.crt /usr/local/share/ca-certificates/
sudo update-ca-certificates
```

## IdP Server Mock

### Usage

``` text
usage: oidc_idp_mock.py [-h] [-v] --cert <path> [--key <path>] [--config-json {<json>}] [issuer_url]

OIDC Identity Provider Mock

positional arguments:
  issuer_url            issuer URL [defult: https://localhost:8443/issuer]

options:
  -h, --help            show this help message and exit
  -v, --verbose         enable verbose logging
  --cert <path>         certificate file for HTTPS
  --key <path>          key file for HTTPS
  --config-json {<json>}
                        configuration JSON
```

Additional configuration options can be provided via the `--config-json` argument, which expects stringified **JSON** object.
The supported options for the configuration object are:

- `number_of_jwks: <int>` - the number of JWKs the mock should generate.
- `token: <token_config>` - access token configuration. If set to an object, an **infinite number** of tokens can be created with the given configuration. If set to an array, only the specified number of tokens will be created. See [token configuration](#token-configuration) for details.
- `faults: <faults config>` - faults configuration. See [fault injector](#fault-injector) section for details.

See [configuration example](#configuration-example) section for more details.

### Server endpoints

Currently the following endpoints are implemented:

- openid-configuration: `{issuer_url}/.well-known/openid-configuration` - for getting configuration,
- token_endpoint: `{issuer_url}/token` - for creating an access token
- jwks_uri: `{issuer_url}/keys` - for getting the list of **JWKs**
- authorization_endpoint: `{issuer_url}/authorize` - to simulate *device authorization flow*
- device_authorization_endpoint - `{issuer_url}/device/authorize` - to simulate *device authorization flow*

### Token Configuration

- `expires_in_seconds`: token expiration time in seconds
- `jwt_id`: the index of the **JWT** key generated by the server, it must be less than `number_of_jwks`
- `payload: <object>`: access token payload

  If the following fields are not defined, the following default values will be pplied.
  - `iss`: set to the `<issuer_url>` provided in the command line options,
  - `iat`: set to the current time,
  - `exp`: set to the current time + `expires_in_seconds`,
  
  If set to `null`, they will be not defined in the token's payload.

Example configuration for an infinite number of tokens:

``` js
{
    token: {
        payload: {
            sub: "user",
            aud: "audience",
            claim: [
                "group1",
                "group1",
            ]
        }
    }
}
```

Example configuration for two tokens with different parameters:

``` js
{
    token: [
        {
            jwk_id: 0,
            payload: {
                sub: "user1",
                aud: "audience",
                claim: [
                    "group1",
                    "group2",
                ]
            }
        },
        {
            jwk_id: 1,
            payload: {
                sub: "user2",
                aud: "audience",
                claim: [
                    "group3"
                ]
            }
        }
    ]
}
```

### Fault Injector

- `jwt_invalid_kid` - sets the `kid` field in **JWT**'s header to `invalid`,
- `jwt_missing_kid` - ommits the `kid` field in **JWT**'s header,
- `jwt_invalid_key` - encodes the **JWT** with a private key not exposed via the `{issuer_url}/keys` endpoint
- `jwt_other_valid_key` - encodes the **JWT** with another valid key exposed via the `{issuer_url}/keys` endpoint, different from the one specified in the `kid` field in the **JWT** header.

By default no faults are applied.

Example:

``` js
{
    token: {
        /* ... */
    },
    faults: {
        jwt_invalid_kid: false,
        jwt_missing_kid: false,
        jwt_invalid_key: false,
        jwt_other_valid_key: true,
    }
}
```

### Configuration Example

With the following configuration the **IdP Server Mock** will:

- create two JWKs
- create a **maximum** of two tokens: the first for `user1`, the second for `user2`
- the first token will be created with the first JWK
- the second token will be created with the second JWK
- the first token will expire in 2 seconds
- the second token will expire in 3600 seconds
- the second token will miss the `iss`, `iat` and `exp` fields in the payload

``` js
{
    number_of_jwks: 2,
    token: [
        {
            key_id: 0,
            expires_in_seconds: 2,
            payload: {
                aud: "audience",
                sub: "user1",
                claim: [
                    "group1",
                    "group2",
                ]
            }
        },
        {
            key_id: 1,
            payload: {
                iss: null,
                iat: null,
                exp: null,
                aud: "audience",
                sub: "user2",
                claim: [
                    "group1",
                    "group2",
                ]
            }
        }
    ]
};
```

With the following configuration the **IdP Server Mock** will create multiple tokens without a claim.

``` js
{
    number_of_jwks: 2,
    token: {
        key_id: 0,
        expires_in_seconds: 2,
        payload: {
            aud: "audience",
            sub: "user1",
        }
    },
};
```

## IdP Mock

The `JavaScript` class representing an OIDC IdP Mock. It starts the [OIDC IdP Server Mock](#idp-server-mock) and provides helper functions for checking if appropriate requests were made against the server.

See the [oidc_idp_mock.js](./oidc_idp_mock.js) file for details.

## Tests Fixture

The `JavaScript` class representing a fixture for **OIDC** tests. It starts the `mongod` process and configured `OIDC IdP Mocks` with given configuration.

It provides some helper functions for convenience.

See the [oidc_idp_mock.js](./oidc_idp_mock.js) file for details.

### Example usage

The following example configures one `OIDC IdP Mock` and one *OIDC Provider* for `mongod`.

It starts both the `OIDC Idp Mock` and `mongod` by calling the `setup()` function.

It authenticates the `user` with **OIDC** mechanism, ensures the **OIDC** configuration was requested, and verifies that a token with expected `client_id` and `scopes` was requested.

At the end it ensures appropriate roles were assigned to the authenticated user.

The `teardown()` function stops both the `OIDC IdP Mock` and `mongod`.

``` js
import { OIDCFixture } from 'jstests/oidc/lib/oidc_fixture.js';

const idp_port = allocatePort();
const issuer_url = "https://localhost:" + idp_port + "/issuer"

var idp_config = {
    token: {
        expires_in_seconds: 3600,
        payload: {
            aud: "audience",
            sub: "user",
            claim: [
                "group1",
                "group2",
            ],
        }
    },
};

var oidcProvider =
{
    issuer: issuer_url,
    clientId: "clientId",
    audience: "audience",
    authNamePrefix: "test",
    useAuthorizationClaim: true,
    requestScopes: ["offline_access"],
    supportsHumanFlows: true,
    authorizationClaim: "claim"
};

var test = new OIDCFixture({ oidcProviders: [oidcProvider], idps: [{ url: issuer_url, config: idp_config }] });
test.setup();

var idp = test.get_idp(issuer_url);

test.auth("user");
idp.assert_config_requested();
idp.assert_token_requested(oidcProvider.clientId, oidcProvider.requestScopes);
test.assert_authenticated("test/user", ["test/group1", "test/group2"]);

test.teardown();
```

## NOTES

### Authorization Flow

The `mongo` shell currently does not support the **Authorization Code Flow**. Therefore, all tests for OIDC authentication use the **Device Authorization Flow** instead. The [Identity Provider Server Mock](#idp-server-mock) implements the `/device/authorize` and `/device/verify` endpoints to support the `mongo` shell's requirements. However, the expected request fields are ignored, and the access token is returned based on the configuration provided for the [Identity Provider Server Mock](#idp-server-mock).
